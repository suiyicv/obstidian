三方面
计算虚拟化
网络虚拟化
存储虚拟化
# 一.虚拟化技术的背景
<span style="background:#affad1">为什么会有虚拟化技术？</span>
(1)资源利用率
硬件配置越来越高，价钱越来越便宜，物理服务器往往只使用了其处理能力的一小部分，导致资源浪费。
(2)成本节省
通过减少所需的物理服务器数量，企业可以节省电力、冷却和物理空间的成本。此外，虚拟化减少了硬件采购的需求，降低了资本支出。
(3)灵活性和可扩展性
虚拟化提供了快速配置和调整计算资源的能力，使得IT部门能够根据需求的变化迅速做出响应。虚拟机可以在几分钟内创建、移动或销毁，而不必经历传统的硬件安装过程。
(4)灾难恢复和业务连续性
虚拟化使得复制和迁移虚拟机变得简单，这对于灾难恢复计划至关重要。虚拟机可以轻松地在数据中心之间迁移，甚至在云中备份，以确保业务连续性。
(5)测试和开发
开发人员和测试团队可以在虚拟环境中安全地尝试新的软件或配置，而不会影响生产环境。这有助于加速开发周期，同时减少对额外硬件的需求。
(6)隔离和安全性
每个虚拟机都有自己的操作系统和应用程序，彼此隔离，这增加了安全性，因为如果一个虚拟机受到攻击，其他虚拟机和物理主机可能不会受到影响。
(7)简化管理
IT管理员可以通过集中管理工具来监控和控制整个虚拟化基础设施，简化了管理流程，提高了效率。
(8)支持云计算
虚拟化是云计算的核心技术之一，它允许资源池化和动态分配，支持弹性伸缩和自助服务模型。

<span style="background:#affad1">但是并不是所有的行业都适合虚拟化</span>
(1)音视频行业
(2)军工，银行，医院

# 二.虚拟化类型
## 1.从设计架构来讲
无论哪种虚拟化技术，最终的所有虚拟机最终都要运行在某一个物理机上
![[Pasted image 20240805091012.png]]

### 1.1 基于平台platform的虚拟化
比如VMware
![[Pasted image 20240704102439.png]]
最底层的物理机由两部分组成：物理机的硬件和物理机的操作系统

然后我们就可以在物理机的基础上创建虚拟机，创建出来的虚拟机也有两层结构组成，最底层是虚拟硬件，你在创建虚拟机的时候，肯定要构建出一堆所谓的虚拟硬件去构成一个完整的虚拟机，虚拟硬件的上层为客户端操作系统，为了区分虚拟机上的操作系统和物理机上的操作系统，我们一般把这个虚机上的操作系统称之为guest os 也叫做客户端操作系统。
有了虚拟硬件和guest os(操作系统)，这才是真正完整的创建出了一个所谓的虚拟机，将来我们就可以在这个虚拟机的基础之上，去部署我们的业务。
从虚拟化技术设计的角度来说，想要实现虚拟化，你就要实现指令的隔离，<font color="#ff0000">即虚拟机和虚拟机之间隔离，虚拟机和真实的物理机隔离，这怎么实现呢？我在虚拟机上面创建了文件，这个文件仅限于存在于我的虚拟机上，不能跑到其他机器上。上层的每个虚拟机都有自己的虚拟硬件，这些虚拟硬件从哪来的？</font>
所以就意味着我们的物理机和虚拟机之间应该有一层隔离，或者说有一层控制软件，我们借助这个控制软件才能创建出所谓的虚拟机的虚拟硬件，借助这个控制软件，帮我们实现一些资源的隔离，帮我们实现指令的控制，<span style="background:#affad1">所以物理机上面还带有一层所谓的虚拟机管理软件，这个虚拟机管理软件在虚拟化技术里面我们统称为Hypervisor</span>,或者叫做VMM，我们装的VMware就是hypervisor当中的一个
<span style="background:#affad1">这就是基于平台的虚拟化架构</span>

(1)VMware 
	workstation/fusion 个人
	EXSI                         企业
(2)Critix 思杰
	XEN
(3)RedHat 红帽
	kvm 个人
	RHEV 企业
(4)微软
	Hyper-v
(5)华为
	FusionCompute

### 1.2 基于操作系统os的虚拟化（容器）
![[Pasted image 20240704103412.png]]
完整的操作系统包含
	内核 ：内核的作用是用来驱动虚拟硬件的
	应用程序
也是通过底层的物理机创建出一些列的虚机供我们使用，但是核心的区别就是，基于操作系统的虚拟化，他创建出来的虚拟机，第一没有自己独立的虚拟硬件，第二，基于系统级别的虚拟化创建出来的虚拟机，你可以理解为他创建出来的就是一堆应用层的命令(应用程序)，他并不是一个完整的操作系统，没有独立的内核，假设我们拿一redis的镜像去创建一个虚拟机，这个虚拟机中只有redis和redis相关的指令(<span style="background:#affad1">bin二进制命令</span>)和redis运行必备的一些依赖(<span style="background:#affad1">lib库文件</span>)
像这种基于操作系统级别的虚拟化你将来想真正能建出来一个应用程序，或者说真正的能建出一个容器，我们在物理机上来得有相关的管理软件，比如docker

<font color="#ff0000">容器和传统的虚拟化有什么区别？</font>
容器就是指基于操作系统的虚拟化，传统的虚拟化， 就是指基于平台的虚拟机化
<font color="#ff0000">为什么基于系统的虚拟化出现之后，很快就侵占了很多传统虚拟化的市场呢？</font>
基于操作系统的虚拟化比传统的平台虚拟化的IO效率要快得多两方面，磁盘的读写，网卡的收发，这就是因为容器没有内核，
<font color="#0070c0">数据IO流程分析</font>
<span style="background:#affad1">传统虚拟机</span>
如果虚拟机网络设置的是没问题的话，虚拟机可以正常联网，但是从技术的角度来讲，虚拟机想要真正上网，虽然他有自己的虚拟网卡，但是上网的数据流量本质上还是得从我们真实的物理网卡出去，<font color="#ff0000">从虚拟机产生访问百度的请求开始，这个数据是怎么走到物理机的网卡分发出去的，他中间大概是个什么环节？</font>
应用程序产生数据，先到虚拟机的虚拟内核，然后再把数据交给虚拟网卡，然而这个整体的虚拟机对于我们真实的物理机来说，也就是相当于一个应用程序，所以数据到了虚拟网卡之后，还要交给下面的虚拟机管理软件，这个应用程序拿到数据之后，才能走到物理机的内核，最后把数据转交给真正的物理网卡
<span style="background:#affad1">容器</span>
他们没有独立的内核，本质上是所有的容器共享物理机的内核，然后还没有自己独立的虚拟硬件，就是由于他和物理机之间共享内核，所以应用程序产生的数据就直接到物理机的内核里了，然后在被转发到真正的物理机网卡上就发出去了，所以容器的数据IO效率更高
## 2.根据Hypervisor的部署方式
原生虚拟化
不依赖于物理机的操作系统，直接在物理机上部署Hypervisor,企业级的虚拟化软件
寄居虚拟化
必须依赖物理机上有操作系统，个人的虚拟化软件

## 3.根据虚拟化技术实现原理
分三类
软件虚拟化
	性能太次被淘汰了
半虚拟化技术
	para-virtulaztion
	提升虚拟机io性能
	借助半虚拟化驱动：virtlO(redhat),vmware-tools,uvp-tools(华为)
硬件辅助虚拟化
	对物理机的cpu指令集进行修改
	物理机的cpu必须开启虚拟化功能的支持
	intel CPU: VT-x
	AMD CPU: amd-V
# 三.安装KVM
## 1.开启虚拟化功能
![[Pasted image 20240704154007.png]]
lscpu | grep -i -E "vt-x|amd-v"
![[Pasted image 20240704155220.png]]
## 2.安装相关软件
yum install -y qemu-kvm qemu-img libvirt virt-install virt-manager libvirt-python libvirt-client virt-viewer
## 3.查看libvirtd服务是否正常运行
检查启动，并且没有报错的状态
systemctl status libvirtd
![[Pasted image 20240704155500.png]]
## 4.验证kvm时候安装成功
查linux内核里面都有哪写内核模块
lsmod | grep -i kvm
![[Pasted image 20240704155526.png]]
## 5.主机网络的变化
![[Pasted image 20240704162202.png]]
iptables -t nat -nL
![[Pasted image 20240704162425.png]]
libvirtd这个服务自动生成的规则
虚拟网络跟虚拟网卡是两个不同的东西，有虚拟网络（虚拟交换机）就会自动在物理机上面生成一块虚拟网卡
![[Pasted image 20240704194619.png]]
借助虚拟网卡把物理机连接到这个虚拟的交换机上，
![[Pasted image 20240704200537.png|450]]
虚拟化软件，创建出来的那个虚拟机，假设网卡选择为nat模式，相当于这个虚拟机也连接到这个虚拟交换机上了
所以我们的物理机借助这个虚拟网卡才可以与虚拟据通信
把物理机上面的虚拟网卡禁用了，相当于物理机连到虚拟交换机上的网线断了，只影响物理机与虚拟机通讯


cat /proc/sys/net/ipv4/ip_forward
![[Pasted image 20240704162249.png]]
路由转发会自动打开
这个路由是在谁和谁之间转数据的呢？
物理机身上还有一快物理网卡，假设叫ens33，这个物理网卡连接的，相当于外界的真实网络
![[Pasted image 20240704165334.png]]
物理机开着路由转发，这个路由转发就是为了在这个虚拟网络和真实网络之间转发数据的
但是他转不出去！！
应为这个虚拟网络他的工作模式是nat模式
![[Pasted image 20240704203047.png]]
122.0网段访问的网段只要不是12.0网段都会自动做源地址转换,会自动识别为外接口IP ，所以他的ip就会 被物理机上面的nat自动转换为ens33的网卡和外接通信

为什么路由转换转不出去还要开路由转发功能呢？
把路由转发关了行不行？
不行！！先查路由后转换，不开路由转发，就无法实现nat转换

# 四.创建kvm虚拟机
## 1.virt-manager 图形化管理工具
![[Pasted image 20240705091427.png|350]]

![[Pasted image 20240705091456.png|299]]
![[Pasted image 20240705091547.png|295]]
![[Pasted image 20240705091645.png|299]]
![[Pasted image 20240705092341.png|298]]
![[Pasted image 20240705092419.png|375]]
![[Pasted image 20240705092613.png|301]]
![[Pasted image 20240705093038.png|450]]
最后启动，安装系统
## 2.virt-install 命令行方式
```bash
[root@localhost ~]# virt-install --name=vm02_centos79 \
> --graphics vnc,listen=0.0.0.0,port=-1,keymap=en_us \
> --memory=1024,maxmemory=2048 \
> --vcpus 2,maxvcpus=4 \
> --disk path=/var/lib/libvirt/images/vm02_centos79.qcow2,size=8,format=qcow2 \
> --bridge=virbr0 \
> --cdrom=/kvm/iso/CentOS-7.9-x86_64-Everything-2009.iso \
> --autostart 
```

## 3.查看虚拟机
virsh list --all
![[Pasted image 20240705095002.png]]
## 4.登录虚拟机操作终端
virt-viewer vm01_centos79 
vncviewer 127.0.0.1:5901 
ssh root@192.168.122.196
# 五.资源调整
1.查看CPU当前数量
virsh dominfo vm01
![[Pasted image 20240705185002.png|500]]

## 1.cpu热添加
virsh setvcpus centos7.0  2 --live
![[Pasted image 20240705185122.png|625]]
前提: 设置cpu最大数量

virsh setvcpus centos7.0  3 --live
virsh dominfo vm01_centos79
![[Pasted image 20240705113112.png]]
## 2.内存气球
作用：提升内存利用率
前提: 1) 设置最大内存量 2) 安装内存气球驱动(virtio)
查看配置文件
virsh dumpxml vm01 | grep -i memballoon
![[Pasted image 20240705113356.png]]
virsh qemu-monitor-command vm01 --hmp info balloon
![[Pasted image 20240705113623.png]]
OOM ----- Out Of Memeroy 内存泄露
当系统发生oom时，内核会产生oom killer机制，根据进程的oom_score随机杀进程
# 六.kvm虚拟机相关文件
kvm虚拟机 ==== 配置文件 + 磁盘镜像文件
## 1.虚拟机配置文件
查看配置文件
/etc/libvirt/qemu
	virsh dumpxml centos7.0
/etc/libvirt/qemu/autostart
虚拟机开机自启动
	virsh autostart centos7.0
修改配置文件
	virsh edit centos7.0
## 2.磁盘镜像文件
ls /var/lib/libvirt/images/
	vm01_disk.qcow2
## 3.删除虚拟机
```bash
virsh destroy vm02_centos76    # 强制关机 
virsh undefine vm02_centos76  # 删除配置文件 
手动删除磁盘文件!!!!!!!
```
## 4.离线迁移虚拟机
将配置文件、磁盘镜像文件拷贝到新服务器【关机状态】
```bash
virsh define   /etc/libvirt/qemu/vm01_centos79.xml
virsh list --all
virsh start vm01_centos79
virsh autostart vm01_centos79
```





