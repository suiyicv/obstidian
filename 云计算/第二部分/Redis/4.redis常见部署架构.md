
常见部署架构

多实例部署  
主从复制  
分片集群  
哨兵集群

1.多实例部署
安装目录: /opt/6380 端口: 6380  
安装目录: /opt/6381 端口: 6381

规划安装目录、配置文件
mkdir -p /opt/638{0,1}/{conf,data}
cp /usr/local/redis50/conf/redis.conf /opt/6380/conf/

编辑实例配置文件
vim /opt/6380/conf/redis.conf 

```bash
bind 192.168.140.10
port 6380
daemonize yes
appendonly yes
pidfile /var/run/redis_6380.pid
loglevel warning
logfile "/var/log/redis_6380.log"
dbfilename dump_6380.rdb
dir /opt/6380/data
appendfilename "appendonly_6380.aof"
```

redis-server /opt/6380/conf/redis.conf 
netstat -tunlp | grep redis
![[Pasted image 20240607173942.png]]
redis-server /usr/local/redis50/conf/redis.conf
netstat -tunlp | grep redis
![[Pasted image 20240607174122.png]]

cp /opt/6380/conf/redis.conf   /opt/6381/conf/redis.conf
sed -ri 's|6380|6381|g' /opt/6381/conf/redis.conf
redis-server /opt/6381/conf/redis.conf 
netstat -tunlp | grep redis
![[Pasted image 20240607174511.png]]
多实例

测试数据读写
redis-cli -h 192.168.1.100 -p 6380
```bash
192.168.1.100:6380> set name martin 
OK 
192.168.1.100:6380> get name 
"martin"
```



2.redis主从复制

在主从复制基础上，整合读写分离提升性能  
从服务器默认为只读  
基于异步的方式进行数据同步  
支持一主多从

规划
192.168.1.100（主）
192.168.1.110（从）

从服务器配置
vim /opt/6381/conf/redis.conf
replicaof 192.168.1.100 6380
如果你的主redis有密码的话
masterauth XXXXXXXXX

redis-server /opt/6381/conf/redis.conf

验证主从状态
netstat -antp | grep redis
![[Pasted image 20240607183011.png]]

```bash
redis-cli -h 192.168.1.100 -p 6380
set a 100

redic-cli -h 192.168.1.100 -p 6381
get a
"100"
set b 20  #只读模式不能写入
(error) READONLY You can't write against a read only replica.
```

主服务器状态：
redis-cli -h 192.168.1.100 -p 6380
info replication
![[Pasted image 20240607183643.png]]

从服务器状态:
redis-cli -h 192.168.1.100 -p 6381 
info replication
![[Pasted image 20240607183849.png]]



主从角色切换
将从服务器提升为主
redis-cli -h 192.168.1.100 -p 6380 shutdown
主redis down了，从redis只能读操作，不能写，此时需要把从redis提升为主redis
redis-cli -h 192.168.1.100 -p 6381
把链接的主服务器的信息全部清掉
SLAVEOF no one
info replication
![[Pasted image 20240607184328.png]]
此时已经变成主redis了
```bash 
192.168.1.100:6381> set b 20  #已经可以写数据了
OK
```

把之前配置的从服务配置注释掉
vim /opt/6381/conf/redis.conf
~~replicaof 192.168.1.100 6380~~  
重启启动
redis-cli -h 192.168.1.100 -p 6381 shutdown
redis-server /opt/6381/conf/redis.conf
此时将6380 设置为从
vim /opt/6380/conf/redis.conf
replicaof 192.168.1.100 6381



3.redis分片集群
redis 3.x版本开始支持的  
作用：所有缓存数据分散存储到不同的redis上，提升读写性能， 提升数据可靠性

6.4-7-04:25

前端产生的数据越来越多，如果后台只有一个redis,所有缓存数据的读写，都要用这一个redis来负责完成，前端数据量越来越大，redis的性能会有所缩减

就算用了读写分离，但是还是单台机器去完成所有数据的写操作
单台性能总会有自己的性能瓶颈

所以就需要把redis扩展成一个分片集群

构建redis的分片集群，至少是6个redis来形成这个集群


前端产生的业务，不是交给这个集群里面的某一个redis来处理，
而是交给这<span style="background:#affad1">整个集群</span>来读写

![[Pasted image 20240607212032.png]]
这个分片集群会根据我们的需要在<span style="background:#affad1">两两redis之间自动形成主从复制关系</span>
所以说实际上能做写的只有三个redis
![[Pasted image 20240607212312.png]]
假如某一redis故障了，他是不会影响缓存数据的读写的
加入一对主从redis服务器同时故障了，那就会造成一部分数据的丢失，缓存的命中率就会收到一定的影响

原理：
缓存关注一个命中率的问题
redis分片集群一旦构建好之后
就会形成16384个哈希槽slot，然后redis服务器平均分

Redis集群使用哈希槽slot进行[数据分片](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87&spm=1001.2101.3001.7020)

Redis集群有16384个哈希槽, 每个key通过CRC16校验后对16384取模来决定放置哪个槽, 集群的每个节点负责一部分hash槽

举个例子,比如当前集群有3个节点,

![[Pasted image 20240607212948.png|500]]
用hash算法的缺点
就算如果又扩展了一个redis变成了四个，这次时就会重新评分哈希槽，这样子就会造成一个部分的缓存数据的丢失
定位数据的算法的优劣势：  
优势：简单  
劣势：随着集群扩容、缩容，会造成缓存数据丢失



分片集群的部署

192.168.1.100  3个集群模式的实例 7001 7002 7003  
192.168.1.110  3个集群模式的实例 7004 7005 7006

192.168.1.110
```bash title:创建三个实例
mkdir -p /opt/700{4,5,6}/{conf,data}
cp /opt/6380/conf/redis.conf   /opt/7004/conf/redis.conf
cp /opt/6380/conf/redis.conf   /opt/7005/conf/redis.conf
cp /opt/6380/conf/redis.conf   /opt/7006/conf/redis.conf
sed -ri 's|6380|7004|g' /opt/7004/conf/redis.conf
sed -ri 's|6380|7005|g' /opt/7005/conf/redis.conf
sed -ri 's|6380|7006|g' /opt/7006/conf/redis.conf
redis-server /opt/7004/conf/redis.conf
redis-server /opt/7005/conf/redis.conf
redis-server /opt/7006/conf/redis.conf
netstat -tunlp | grep redis
```
![[Pasted image 20240607214625.png]]
192.168.1.100
按同样的方式建立三个实例
 netstat -tunlp | grep redis
![[Pasted image 20240607215002.png]]


编辑配置文件，修改如下两条
==cluster-enabled yes== 
==cluster-config-file nodes-7001.conf==
其他原始配置如下
bind 0.0.0.0
port 7001
daemonize yes
appendonly yes
pidfile /var/run/redis_7001.pid
loglevel warning
logfile "/var/log/redis_7001.log"
dbfilename dump_7001.rdb
dir /opt/6380/data
appendfilename "appendonly_7001.aof"

设置好一个配置文件后，其他的redis直接复制就可以了

六个redis实例都进行修改
重启后查看端口，以7001为例
vim /opt/7001/conf/redis.conf
==cluster-enabled yes== 
==cluster-config-file nodes-7001.conf==
redis-cli -h 192.168.1.100 -p 7001 shutdown
redis-server /opt/7001/conf/redis.conf

全部配置完成后，查看端口
netstat -tunlp | grep redis
![[Pasted image 20240607220039.png]]

![[Pasted image 20240607220510.png]]

全部配置完成后查看进程
ps -elf | grep redis
![[Pasted image 20240607221142.png]]
![[Pasted image 20240607221110.png]]



 创建分片集群
 redis-cli --cluster create \
![[Pasted image 20240607222614.png]]
--cluster-replicas 1  # 这里的1就是指为主redis分一个从redis

![[Pasted image 20240607222306.png]]
![[Pasted image 20240607222518.png]]


连接集群测试数据读写
-c就是连7001，所在的集群，不加就算连的7001这个单独的redis
redis-cli -h 192.168.1.100 -p 7001 -c  
192.168.1.100:7001> set beyond v10
-> Redirected to slot [11404] located at 192.168.1.100:7002
OK
192.168.1.100:7002> set url www.jd.com
OK




