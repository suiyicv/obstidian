# 一.linux基础
Linux操作系统的内核，叫做<span style="background:#affad1">kernel</span>，如果希望找到它的最新源代码，我们介绍过了网站：kernel.org。kernel提供操作系统的最基本的功能，驱动硬件、初始化内存、CPU等。
什么是<span style="background:#affad1">shell</span>
Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器)
Shell接收用户输入的命令并把它送入内核去执行
Shell起着协调用户与系统的一致性和在用户与系统之间进行交互的作用
![[Excalidraw/Drawing 2024-07-10 19.49.48.excalidraw.md#^group=J6ZFZ8fHNER5oMS4pwtCd]]
## 0. 快捷键 
ctrl+alt + F1 图形 F2-F6文本
![[Pasted image 20240709200450.png|500]]
`CTRL+C`：发送 `SIGINT` 信号，通常用于中断并终止一个进程。
`CTRL+Z`：发送 `SIGTSTP` 信号，用于暂停（挂起）一个进程，但不终止它。

查看别名
alias                      ：查看别名
alias la = 'ls -al'    ：设置临时别名
unalias la              :   取消别名
永久设置别名个人： vim ~/.bashrc
永久设置别名全局： vim /etc/bashrc

info在线帮助
info ls 
pinfo ls

man手册
man 1 用户命令 *  man 2 系统调用 
man 3 库调用        man 4 特殊文件 
man 5 配置文件 *  man 6 游戏 
man 7 杂项            man 8 系统命令 *
man -k pass     :   模糊查询
<span style="background:#affad1">man -f passwd</span>： 显示passwd在那些章节有描述
![[Pasted image 20240710190538.png]]
mandb             :   刷新man手册数据库


[date](https://wangchujiang.com/linux-command/c/date.html)
date +'%Y/%m/%d   %T  %p'
![[Pasted image 20240710191244.png]]

[type](https://wangchujiang.com/linux-command/c/type.html)
![[Pasted image 20240710192920.png]]
别名>外部>内部
按照优先级和执行顺序，当输入一个命令时，Shell首先检查它是否是一个别名，如果是，则展开别名；然后检查是否是一个内置命令，如果是，则直接执行；最后，如果既不是别名也不是内置命令，Shell将在`PATH`环境变量指定的目录中查找该命令对应的可执行文件，即外部命令。

which
查找并显示给定命令的绝对路径
![[Pasted image 20240710193849.png]]

history
查看历史命令，默认可以存储1000条历史命令
调用之前的命令
！+历史命令首字母/命令 
！+历史命令编号




## 1. 文件管理
ls
```bash
-a -A -l -d -h -t -r -S -R
```
![[Pasted image 20240710091046.png]]
第一段: 文件类型 
```bash title:文件类型
文件类型:(7种) 
- 普通文件 file 
d 目录文件 directory 
c 字符设备文件 character 
b 块设备文件 block 
s 套接字文件 socket 
p 管道文件 pipe 
l 符号链接文件(软链接) symbolic
```
 第二段: 基本权限 
 第三段: 是否设置了ACL权限 
 第四段: 硬链接数 
 第五段: 拥有者 
 第六段: 所属组 
 第七段: 大小(字节),b4it8=1Byte 1024 1K M G
 第八段: 最后一次修改时间 
 第九段: 文件名

cd
```bash
.        当前目录
..       上级目录
cd .   刷新目录
cd -  上次工作目录
```
linux的HFS标准
Filesystem Hierarchy Standard，简称<span style="background:#affad1">FHS</span> -文件系统层次结构标准
"/" 跟目录下每个目录的作用 
<span style="background:#affad1">bin</span>        用户可执行目录(命令 root 和 普通) 
<span style="background:#affad1">sbin </span>     系统可执行目录(命令 root) 
lib         库文件目录(32位) 
lib64     库文件目录(64位)
<span style="background:#affad1">dev</span>       设备文件目录
usr        应用程序目录
var        服务器数据目录(数据 日志) 
srv        服务器数据目录 
<span style="background:#affad1">etc</span>        配置文件目录 
tmp      临时文件目录 
boot     服务器启动目录(内核和启动文件) 
media   媒介目录(u盘,cdrom) 
mnt      其他挂载点 opt 第三方应用程序目录 
proc     伪文件系统(内核参数,进程信息,硬件信息) 
sys       伪文件系统(c 配置文件目录 内核参数,进程信息,硬件信息) 
run       进程锁目录 
<span style="background:#affad1">root</span>      root管理员家目录
<span style="background:#affad1">home</span>   普通用户家目录 

pwd
绝对路径: 从/开始的路径 
相对路径: 从当前目录开始路径或非根开头的路径
cat 
```bash
-n 显示所有行的行号(包括空行)
-b 显示有效行(不包括空行）
```
head
tail
```bash
默认前/后十行
-n number  
实时监控并自定义显示行数
tail -n 20 -f filename
```
less
more
touch
```bash
touch {a,b,c}{1..3}.txt
touch /opt/file7 /tmp/file8
```
mkdir
```bash
mkdir /opt/cc.txt /etc/tt.txt
mkdir {x,y,z}{1..5}
mkdir -pv /opt/x/y/
-v:显示提示信息
```
cp
```bash
-r:递归复制
-p:保留权限
-a:=rp
```
mv
```bash
移动/改名/重命名
```
rm
-f 强制删除 
-r 递归删除目录时使用

file
用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。

## 2. vim文本编辑器

不仅可以编辑已存在的文件，还可以创建新文件
三种模式：命令模式，输入模式，末行模式
命令模式：用于光标移动复制删除
输入模式：编辑文本
末行模式：保存退出，设置环境显示行号制表符，设置缩进等
### 2.1 命令模式：
#### (1)进入输入模式
<span style="background:#affad1">a </span>    当前字符后输入
A     当前行行尾输入
<span style="background:#affad1">i</span>      当前字符前输入
I      当前行行首输入
<span style="background:#affad1">o</span>     当前行下一行输入
O    当前行上一行输入 
s     删除当前字符后输入 
S    删除当前行后输入
#### (2)光标移动
键盘上的↑↓←→ 上下左右箭头 移动光标，<span style="background:#affad1">hjkl 左下上右</span> nh:向左移动n个字符
0               将光标定位到行首
$               将光标定位到行尾
gg             将光标定位到文章首部
shift+g/G  将光标定位到文章尾部
nG /10G    将光标定位到第10行
#### (3)复制粘贴
y                复制
y^              复制光标所在位置到行首
y$              复制光标所在位置到行尾
yw             复制一个单词
yy              复制一行
<span style="background:#affad1">nyy </span>           复制光标一下的多行
p/P            黏贴(<span style="background:#affad1">p</span>当前行下一行) (<span style="background:#affad1">P</span>当前行的上一行)
#### (4)删除撤销
d               删除
dd            剪切/删除(p P)
ndd          剪切/删除n行
d^             删除当前字符到行首(不包含当前字符) 
d$/D        删除当前字符到行尾
<span style="background:#affad1">dgg </span>         从当前行删除到首行(包含当前行) 
<span style="background:#affad1">dG   </span>           删除当前行到尾行(不包含当前行)

<span style="background:#affad1">u    </span>             撤销上一步的操作
.               重复之前的操作
ZZ            保存并退出
注意：大写字母都可以用shift+小写字母代替
### 2.2 末行模式
#### (1)常用指令
shfit + ；                   进入末行模式
:w /tmp/cc.txt           另存为
:1,3w /tmp/new.txt   将1到3行另存为
:x                                如果未修改直接退出;如已修改保存并退出
:r /etc/passwd           将/etc/passwd文件内容读取到当权文件光标处
:! command               临时输入linux命令
:e!                               重新打开当前文件
:e /root/aa.txt            打开另外一个文件
:X                               加密文件 
:X                               将密码设置为空，即可取消密码
#### (2)环境设置
:set nu/nonu                                显示行号
:set list/nolist                               显示空格或者制表符
:set tabstop=16                           文件中所有制表符都设置为16
:set softtabstop=16                     只更改设置后的制表符长度
:set autoindent/noautoindent    自动缩进
set ignorecase smartcase           搜索忽略大小写
:noh                                              取消高亮

#### (3)vim配置文件
vim ~/.vimrc                                 个人永久开启行号
set nu
vim /etc/vimrc                             所有人永久添加行号
set nu 

### 2.3 可视化模式
按 v 进入可视化模式
按 V 进入行可视化模式，选择整行
按 Ctrl+V 进入可视块模式
y：复制选中的文本到 Vim 的寄存器
d：删除选中的文本
p：粘贴之前复制的文本
u：将选中的文本转换为小写
U：将选中的文本转换为大写

### 2.4 查找替换
/关键字    从上往下搜索     n下一个 N上一个
?关键字   从下往上搜索

| 名称  | 作用    |
| --- | ----- |
| s   | 行     |
| g   | 到该行结尾 |
| %   | 全文    |
| c   | 交互式   |
末行模式做替换  /old/new/
:%s/ab/xx/gc      交互式的把文本中所有行中的ab换成xx 
3,5s/ab/xx/gc     交互式的把文本中3到5行中的ab换成xx

## 3. 用户管理
Linux系统中，用户被创建时，系统都会分配一个用户ID号，简称UID。同时也会给该用户创建一个用户组，简称GID。系统通过ID号来识别用户。

| 分类    | UID     | 作用          |
| ----- | ------- | ----------- |
| 超级管理员 | 0       | 系统管理/基本所有权限 |
| 普通账号  | 1000以上  | 系统管理/使用权限   |
| 系统账号  | 201-999 | 不能登录/用于启动应用 |

| 分类     | UID     | 作用             |
| ------ | ------- | -------------- |
| 超级管理员组 | 0       | 让其他用户加入组，使用组权限 |
| 普通账号组  | 1000以上  | 让其他用户加入组，使用组权限 |
| 系统账号组  | 201-999 | 让其他用户加入组，使用组权限 |
用户组的作用，将相同兴趣用户加入组内按统一权限管理。linux系统中，用户可以加入组，组不能再加入组。
### 3.1 用户管理
增删改查
useradd，usermod，userdel，id，passwd
#### (1)useradd添加用户
useradd 选项 选项参数 用户名

| 选项  | 作用      |                                                                                                                                                                                                                        |
| --- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -u  | uid     | id号会按当前系统最大用户id号顺延+1                                                                                                                                                                                                   |
| -g  | gid     |                                                                                                                                                                                                                        |
| -c  | comment | 用户描述信息（非必要）                                                                                                                                                                                                            |
| -d  | home    | 指定家目录位置如果，需要使用不存在的目录                                                                                                                                                                                                   |
| -s  | shell环境 | 系统默认值/bin/bash，<span style="background:#affad1">/bin/bash</span>可登录的用户，可以和系统交互；<span style="background:#affad1">/sbin/nologin</span>非交互式shell，不能登录系统，只能加载应用；<span style="background:#affad1">/bin/false</span>,不能和系统交互 |
| -G  | 附加组     | 附加组，也称为从组，将用户加入其他组中                                                                                                                                                                                                    |
| -o  | 重复uid   | 重复使用UID时使用（非常不推荐）                                                                                                                                                                                                      |
```bash
useradd -g 4000 group2  
```
![[Pasted image 20240713102246.png]]
创建一个名为 group2 的新用户，并将这个用户的<span style="background:#affad1">主要组</span>设置为GID为4000的组。但是这个组不存在不能创建。
```bash
useradd -G root tom  
```
将tom加入到root组内
![[Pasted image 20240713102943.png]]
主要组g和附加组G区别
-g gid 主要群组，修改用户gid 
-G groups 附加组，将用户加入到哪个附加组内
```bash
useradd -g root tom 
```
![[Pasted image 20240713103546.png]]
意义为指定tom的主要群组为root，该操作影响了/etc/password中的gid部分，之后使用tom创建文件时所有者为tom，所属组为root 
```bash
useradd -G root tom 
```
![[Pasted image 20240713103645.png]]
意义为给tom指定附加组为root，也就是将tom加入了root群组中，当tom访问所属组为root的文件时可以使用root组权限
```bash
useradd -u 2005 -g 2000 -G 0 -c 'test user' -d /mnt/abc6 -s /bin/bash wwh
useradd -o -u 0 test1    # 重复使用UID时使用
```

#### (2)usermod 修改用户信息
usermod 选项 选项参数 用户名
-a 保留原始附加组，加入额外的组
usermod -G wheel newuser
![[Pasted image 20240713104600.png|550]]
usermod -aG root newuser
![[Pasted image 20240713104620.png|550]]
-u  -g  -c  -d  -s  同用户添加
修改家目录的方法
方法1：
```bash
usermod -d /tmp/jack jack 
mv /home/jack/ /tmp/
```
方法2：
```bash
usermod -m -d /home/jack jack
```
-m：这个选项表示移动用户的主目录到新的路径。如果新家目录不存在，usermod 会尝试创建它。

#### (3)userdel删除用户
创建用户时(useradd user)会在系统中产生相关文件：
/home/user 用户家目录
/var/spool/mail/user 邮箱文件
/etc/passwd中写入用户信息
/etc/group中创建对应名称的用户组

userdel user1 只删除/etc/passwd用户信息和/etc/group中组信息，而不删除家目录及邮箱
userdel -r       删除用户同时删除家目录及邮箱信息

#### (4)用户配置文件
vim /etc/passwd
<span style="background:rgba(163, 67, 31, 0.2)">wwh</span>:<span style="background:rgba(240, 200, 0, 0.2)">x</span>:<span style="background:#affad1">1001</span>:<span style="background:#40a9ff">0</span>:<span style="background:#ff4d4f"> </span>:<span style="background:rgba(3, 135, 102, 0.2)">/home/wwh</span>:<span style="background:#9254de">/bin/bash</span>
第一段:用户名
第二段:密码占位符,现已转存/etc/shadow如果删除x，用户则可以直接免密登录
第三段:uid
第四段:gid
第五段:描述
第六段:家目录
第七段:shell
#### (5)passwd设置用户密码
passwd 选项 用户名
passwd  直接回车  修改当前用户的密码
passwd  user          给user创建密码，只有root可以给别人设置密码，普通用                                 户只能改自己的密码
方法一:交互式
![[Pasted image 20240713154914.png]]
方式二:通过标准输入的方式
```bash
echo 123456 |  passwd --stdin root
```

#### (6)切换用户
su    用户名
su - 用户名  - 会切换环境变量，推荐这个方法
#### (7)验证用户是否存在
id username

### 3.2 组管理
#### (1)添加组
groupadd  test
groupadd -g 3000 test
#### (2)修改组
-g 修改组ID 
-n 修改组名
```bash
groupmod -g 3000 test
groupmod -n newtest test   # 修改test组名为newtest
```
#### (3)删除组
groupdel uplooking
#### (4)gpasswd
gpasswd命令可以将用户添加到组或将用户从组中删除(<span style="background:#affad1">附加组</span>)
gpasswd 选项 组名
-a 将用户添加到组 
-d 将用户从组中删除
gpasswd -a cl mysql  将cl加入mysql组
![[Pasted image 20240713161105.png|500]]
 gpasswd -d cl root   将cl从root组删除
 ![[Pasted image 20240713161235.png|500]]
#### (5)组配置文件
 vim /etc/group
 <span style="background:#affad1">cl</span>:<span style="background:rgba(240, 200, 0, 0.2)">x</span>:<span style="background:#d3f8b6">1002</span>:<span style="background:#40a9ff">  </span>
 第一段: 组名 
 第二段: 组密码占位符号 
 第三段: gid 
 第四段: 用户列表

### 3.3 密码管理
#### (1)密码配置文件
vim /etc/shadow
<span style="background:#affad1">user1</span>:<span style="background:rgba(240, 200, 0, 0.2)">!!</span>:<span style="background:rgba(136, 49, 204, 0.2)">19917</span>:<span style="background:#ff4d4f">0</span>:<span style="background:#40a9ff">99999</span>:<span style="background:rgba(240, 107, 5, 0.2)">7</span>:<span style="background:#affad1">  </span>:<span style="background:#fff88f">  </span>:<span style="background:rgba(173, 239, 239, 0.55)">  </span>
第一列：用户名
第二列：密码      密码字段为空没有密码；密码字段不为空 加密后的字符串，表示密码已经设置  ； !! 锁定密码状态   ； * 永久不能登录系统
第三列: 密码的最后一次修改时间；从1970年1月1日至今的天数
第四列: 密码的最小时间；密码最后一次修改后多少天内不能再重复修改
第五列: 密码的最大时间(密码有效期)，最后一次修改多久后必须变更密码
第六列: 密码过期前警告时间
第七列: 密码过期后帐号宽限时间
第八列: 帐号有效期（账号失效后，无论密码是否过期都不能使用）
第九列: 保留列
#### (2)修改密码
方法一:交互式
![[Pasted image 20240713154914.png]]
方式二:通过标准输入的方式
```bash
echo 123456 |  passwd --stdin root
```

#### (3)锁定用户
usermod -L robin：这个命令会<span style="background:#affad1">锁定</span>用户 `robin` 的账户，使其无法登录系统。
usermod -U robin：这个命令用于<span style="background:#affad1">解锁</span>用户 `robin` 的账户，如果之前该账户被锁定的话
#### (4)锁定密码
passwd -l robin：锁定用户 `robin` 的密码。这将禁用该用户的密码认证，使其无法通过密码登录系统
passwd -S robin：显示用户 `robin` 的密码状态。这个命令会输出关于用户密码的详细信息，包括密码是否已锁定、最后一次更改密码的日期、密码到期日等
passwd -u robin：解锁用户 `robin` 的密码

#### (5)配置文件
/etc/login.defs (uid,gid范围)
![[Pasted image 20240713183319.png]]
/etc/default/useradd
![[Pasted image 20240713183407.png]]


# Openstack
云操作系统
提供了一个构建云服务的框架
## 1.云的简介
大量的虚拟化的资源池
云的核心底层技术：虚拟化
### 1.1 优势
按需自助的服务
广泛的网络接入
弹性伸缩
资源池化
### 1.2 根据云平台提供的服务不同
Iaas
	基础设施(服务器、存储、网络设备)即服务
	Infrastracture As a Service
Paas
	平台即服务
	Platform As A service
Saas
	软件即服务
	Software As A Service
![[Pasted image 20240711220044.png]]
### 1.3 根据提供服务范围不同
- 公有云
- 私有云
- 混合云
## 2.openstack核心组件
云操作系统，构建云平台提供了一个框架
现在外面一些做云的厂商，他们自己的私有云产品都是在openstack的基础上做了大量的二次开发，然后形成了自己的产品
<span style="background:#affad1">要对openstack里面的一些核心组件要有一个整体的认知</span>
openstack是一堆软件的组合，统称为openstack
<font color="#d99694">openstack在云平台中起什么作用？</font>

openstack版本 
命名是按字母命名的，ceph这个软件的命名就是随openstack来的，也是按英文字母命名

核心组件
nova glance neutron cinder switft keystone heat lronic dashboard
![[Excalidraw/Drawing 2024-07-10 19.49.48.excalidraw.md#^group=FRBwRiMKyPVnAMyw6VAB5|700]]
云上这些所有的组件都是给<span style="background:#affad1">云服务器(VM)</span>服务的
### 2.1 Nova组件
<span style="background:#affad1">提供计算compute服务</span>
负责云服务器(计算资源)的<span style="background:#affad1">整个生命周期管理</span>(创建，查看，更新，删除)
我们在任何一个云平台上面，之所以能购买云服务器，配置好参数以后这个云服务器就能够被真正的创建出来，然后这个云服务器创建相关的所有操作都是由Nova这个组件负责完成的

**Nova的核心组件**
组件内部有设计了很多的子部件
![[Pasted image 20240711204737.png|525]]

| 名称               | 作用                             |
| ---------------- | ------------------------------ |
| nova-api         | 接收关于云服务器的操作请求                  |
| nova-scheduler   | 调度操作请求                         |
| nova-compute     | 调用计算节点的Hypervisor真正实现云服务器创建、删除 |
| nova-conductor   | 与数据库交互，处理云服务器的元数据信息            |
| nova-consoleauth | 提供认证，认证登录云服务器时，用户名、密码、密钥       |
| nova-novncproxy  | 提供VNC的方式登录服务器                  |

nova-api 
主要负责接收有关于云服务器的操作请求，将来你要拿openstack搭建云平台，无论是通过UI还是通过命令行，你要搭建云服务器或者删除云服务，总要有人来接受你的请求，这个就是nova-api做的事情
nova-scheduler是用来做调度的
按照官方给我们的建议自己要去搭建openstack的话，至少要两个机器
![[Pasted image 20240711205452.png|450]]
一个控制节点，一个计算节点
控制节点需要装一些openstack运行必备的一些基础组件（时间同步，mysql，消息队列，memory catch等）nova在设计的时候内部会涉及很多个子进程，当创建云服务器的时候，要传递很多数据，为了实现同一个组件内部多个不同的子进程之间的高效通信，需要消息队列的支持，memory catch跟redis类似，是用来做缓存的，存一些用户的令牌，用户的一些认证信息
计算节点，云上边所创建出来的那个云服务器，本质上就是一个kvm虚机，计算节点就是将来跑虚机的结点。所谓的云服务器，就是跑在计算节点上的一个虚拟机，要是做一个稍微有点规模的云平台，计算节点不可能只是一个（成百上千）
我们就拿创建来说，第一个进程叫做nova-api，他收到一个请求，这个api肯定能从这个请求里面看到我要建一个云服务器的名字，我要什么样子的规格，我的镜像是什么样的，这些请求里面应该包含这些数据，这些数据叫做云服务器的元数据，接收到这些请求之后，再通过keystone验证这个请求是合法的后，这个api会联系DB，把云服务器的元数据存储在这个数据库里面
nova-scheduler这个调度，是调度什么的呢？创建云服务器的时候，这个机器应该建在那个计算节点上？假设我们这个规模里面有几十甚至几百个计算几点，这么多计算节点存在，是不是应该有一个所谓的调度，帮我们选择一个合适的节点，来真正创建这个云服务器，这就是调度。
调度就是负责选择一个合适的计算节点，再去真正的去创建这个云服务器

nova-compute是跑在计算节点上的一个进程，我们之前说，nova节点是负责创建删除云服务器的，但是这个创建删除的操作，并不是nova做的，而是hypervisor
nova这个组件他本身并没有创建删除虚拟机的功能，其实是这么一回事
api接受到一个请求，然后这个请求通过scheduler调度帮我们去选择一个合适的计算节点创建虚拟机，那这个云服务器是怎么建出来的？我们假设在第一个节点上面创建虚拟机。这个调度，把这个请求调度到第一个节点，这个请求是由一个叫做nova computer的节点接收的
他接收到有人给我发了一个请求，让我去建一个虚拟机，但是nova本身并没有真正创建删除的功能，真正的创建删除是靠我们装在这计算机点上的hypervisor实现的（默认使用的是kvm）

nova-api接收到一个创建请求，然后又这个调度帮他选着一个合适的计算节点，然后这个计算节点选择了之后，再把这个请求转交到这个计算节点身上的compute，nova-computer,真正拿到这个要创建或者删除的请求之后，他会去调用我们在计算节点上真正装的这个hypervisor来真正的实现创建，真正的实现删除
现在所有的hypervisor都是硬件复制的虚拟化，将来做基础环境准备的时候，所有的计算节点必须开启虚拟化功能

nova-compute接收到要创建这个服务器的请求，他确实要调用hypervisor真正的把这个虚机建出来，但他在见这个虚拟机的时候，他是不是应该需要知道这个虚拟机的名字叫什么？应该分配多大的硬盘，应该介入到那个网络当中去，他是不是应该知道这些信息呀，但是他是怎么 知道这些信息的呢？这就涉及到另一个组件叫做nova-conductor

nova-conductor,真正调用hypervisor之前nova-compute 是不是要去数据库里面拿到这个要被创建的服务器的元数据信息，拿到之后，再去按照这个元数据，再去调用hypervisor把服务器按需创建出来，谁来帮nova-compute 去数据库里面那这个信息呢？就是中间的nova-conductor
这就是核心的四个进程，这四个进程一个不成功，虚拟机就创建不出来



Nova只是单纯的提供建服务器的功能，但是这个服务器真正能创建成功，还需要其他组件的配合，比如说创建虚拟机的时候需要选择镜像，这个镜像谁提供的？就是下面的glance组件

### 2.2 Glance组件
提供镜像image服务
负责镜像的上传，查看，删除
结合虚拟化来说，这里所说的镜像，其实就是一个.qcow2格式的磁盘文件，或者是.iso格式的系统镜像文件
两个子进程
glance-api
接收关于镜像的api请求的调用，包括镜像的查看更新存储
![[Pasted image 20240712183404.png]]
glance在存储镜像的时候支持多种存储方式，S3亚马逊对外提供的一个对象存储服务
glance-registry 就是用来和后台的数据库交互，来存储一些和镜像相关的数据(镜像的元数据信息)。open stack里面的每个组件运行的时候都会产生数据，所以都需要关联后端数据库存储


### 2.3  Cinder组件
提供卷volume服务
负责为云服务器提供卷服务(云硬盘/虚拟磁盘)/虚拟磁盘的整个生命周期的管理

如果你要子啊你的云平台里面构建这个卷服务的话，建议在增加一个节点block storage 块存储节点
![[Pasted image 20240712200416.png]]
无论是你服务器本地插了很多硬盘也好，还是说你的存储节点后面关联了很多存储设备，你既然作为整个云平台对外提供块存储服务，那其实，将来就是你得把你提供的这个零散个磁盘空间给集中到一起，然后在往外边分，也就说先虚拟出一个大的存储池，然后在根据用户的需求把磁盘空间划分出去。
这些零散的空间通过什么技术能够集中到一起去？
通过lvm集中到一起去，云磁盘底层里面涉及到的一个核心技术就是当初学的逻辑卷，把所有的磁盘形成一个卷组，通过这个卷组就想到于把所有的空间集中到了一起，云平台搭好以后，我们的这个终端用户购买硬盘，无非就是在这个卷组里面给我划分一个一个的卷

按照我们的open stack网络拓扑来说，其中有一类是计算节点，计算节点就是用来跑虚拟机的，现在有一类存储节点，他底层可以通过lvm这样的底层技术，把所有的空间集中起来，然后再往外分配，假设云平台搭设完成以后，有人购买一个5GB的硬盘，其实就是底层的lvm检出了一个5G的卷，那着里面有什么问题呢？这个卷肯定是建立在存储节点上的，而你买的云服务器是跑在计算节点上的，那从最终使用的角度来讲，我肯定是要把这个硬盘，加到某一个云服务上面去，这里面涉及到的问题就是，你的云服务器在计算节点上，你的5G的硬盘在存储节点上，怎么通过什么东西把这个5G的磁盘关联到计算节点上？
能往外直接共享块设备的，按照我们之前说的存储就是san存储，按照协议来说就是iscsi协议，将来用户在我这购买了虚拟磁盘之后，为了这个磁盘能够关联到某一个云服务器上面去用，采用的就是共享的方式，走的就是iscsi协议和scsi协议
什么时候走iscsi呢？就看你中间所有设备的网络连接，如果走的是IP网络走的就是iscsi，如果走的是光纤网络走的就是scsi了。

涉及的技术：LVM、iSCSI/SCSI共享块设备
cinder组件的核心进程
![[Pasted image 20240712202744.png|450]]

cinder-api，负责接收请求、路由请求到cinder-volume上
cinder-scheduler，负责选择合适的存储节点
cinder-volume，负责调用底层的存储接口/驱动真正创建、销毁虚拟磁盘
cinder-backup，负责提供磁盘备份服务，配合swift对象存储使用






### 2.4 neutron组件
提供网络network服务
负责为云服务器提供网络连接
比如：vpc;sg安全组;nat;vpn;负载均衡器
早年的iaas主要是提供基础设施服务的，基础设置就三样，计算；网络；存储
单纯是iaas平台的话 nova glance cinder neutron 是最核心的组件
整个所有的openstack里面所有的组件设计最复杂的就是neutron
核心进程就一个
neutron-server
接收用于关于到我们这个云平台上面网络创建呀，查看完了网络接入这些请求，接收到请求之后，neutron-server还会把这些请求转发到合适的网络插件上面
单说neutron，是提供网络连接的，但是从整个open stack的设计的角度来讲，这个云平台上面所有的网络功能都是通过各个插件来的
![[Pasted image 20240712190011.png]]
网络的元数据信息也是要存到后边的数据库的
每个插件和neutron-server高校交互的时候都通过消息队列

所有的云平台后端核心的技术就是虚拟化技术

网络虚拟化技术
vpc怎么实现的？
最基本的网络功能是靠Open vSwitch 实现的，这就是网络上的一个虚拟化技术，对于虚拟话网络里面所说的那个虚拟网络就相当于模拟生活中的交换机的功能，它主要用到的技术就是open vswitch 
Linux bridging 桥接技术

vxlan 
在云平台上面，你创建一个vpc你就要指定一个网段，这个网段我可以指192；你也可以指定为192，对于华为云的后端而言，他怎么支持这么多人在他身上建出来这么多的虚拟网络呢？单纯从数量和网络隔离上面来说，他用的是什么技术呢？用的技术就是vxlan
vlan是用在交换机上的技术，vlan能够实现网络隔离的功能(划分广播域)要给，一个交换机上可以创建4096个，交换机在碰到广播类型的数据的时候他默认会泛洪
单纯的虚拟化环境里面那一个虚拟网络就相当于一个vlan，从云的角度来说，我们也可以理解为一个vpc就是一个vlan。
就刚才我们说，我们建了多个vpc他是怎么帮我们实现网络隔离？思想是vlan的这个思想，但是用技术不是vlan这个技术，应为你在建vlan的时候一个交换机上面最多只能建立4096个vlan，如果放在现实中的环境肯定是够的，但是放在云上肯定是不够的，所以自动虚拟化技术出现之后vlan技术也发生了一个改革，产生了vxlan，vxlan相当于vlan核心有两个好处，第一个很大程度上扩展了这个数量（不受数量的限制）
第二个好处就是，在云上或者从物理环境上来说，给我们做设备迁移带来了很大的便利，
平常的迁移IP地址会变，IP地址变了会影响业务的，牵一发而动全身，而vxlan呢，在原始的数据包上的最外层又增加了一个二层封装，然后就可以实现，将来主机也好，服务器也好，他在跨网段迁移的时候可以保存IP不变。
数据封装要封装个样东西，源端口目的端口，源IP目的IP，端mac目的mac，这是传统的数据封装，如果这个数据是跨网段传输的，它必然需要经过路由，传统的路由是根据目的ip来转发数据的，所以vxlan改变了传统的根据IP的方式转发数据的方式，他子啊传统的数据包上又多加了一层新的mac地址的封装，有了这个新的mac地址的封装，哪怕你这个地址和以前是不同网段的，我不按照IP的方式走，我按照mac地址的方式，这样按网络上来说，我就可以实现一个2层的跨传，哪怕这两个设备不在统一个网段里面，我一样可以通过mac地址的方式帮你把数据转出去，但是中间要经过一个vxlan的隧道，而且你的网络设备必须要买支持vxlan功能的网络设备(主流)


sdn
软件定义网络
主要实现的是网络设备的控制平面和数据平面的隔离，说白一点就是实现网络设备的自动化
在云上面我建了一些vpc，很多人都会建很多vpc，虽然对于我们终端用户来说我们不同的用户之间的资源是隔离的，但是对于整个华为云的后台而言，我们建的所有的东西都是表现在一个云平台里面的，他是一个整体，假设华为内部人员要对云上的vpc进行策略上的更新，但是一个个改效率太低了，这个时候就可以用到sdn，通过sdn就可以实现集中的向所有的网络设备下发统一的配置
sdn又分两类
硬sdn 专业的硬件，单独的设备(sdn控制器)
软sdn  软件/平台，来对网络做集中的控制

### 2.5 swift组件
提供对象存储服务object storage /对象存储
负责存储磁盘镜像文件，磁盘备份文件

配合glance用来存储镜像或cinder卷的备份
单说glance他是负责云平台后端的这个镜像的上传下载，比如说我们将来这个云平台构建好之后，我们要大量的往云平台上面传一些镜像，然后glance支持很多种方式来存储这个镜像。
比如你要是最小化部署的话，你可以在服务器下面建一个文件夹然后配置glance使用这个文件夹来存储镜像，按真正的云平台构建来说，云平台的后端肯定有专业的存储设备，然后glance也支持去关联后端的设备来存储这些对象
，或者就是在云平台里面装一个swift，这就相当于云平台里面有了对象存储服务，将来也可以配置我的glance去关联swift这个对象存储，在这个对象存储里面存储上传的镜像文件

还有一方面提供云硬盘备份服务，云硬盘备份服务按照单纯的虚拟化来说就是，对硬盘建快照

### 2.6 cellometer组件
提供计量服务
计量服务不单单指计费，比如说这个云服务器是什么时候买的，用了多长时间什么时候删的，然后从费用来说，应该扣多少钱。你买的公网IP什么时候买的，用了多少带宽多少流量怎么计费
### 2.7 keystone组件
提供认证identity服务，最最核心的组件
负责用户的认证；鉴权
这个认证包含两个方面
(1)用户的认证
(2)我们需要有个整体意识，虽然我们是openstack里面有这么多组件，各干各的事，但从整个云平台的实现角度来讲，这些组件和组件之间是有关联的，而且这些组件是多个团队开发的，这些组件在相互传递数据，相互沟通的时候，他们需要找keystone做认证
### 2.8 dashboard组件
提供web UI 界面，web UI 可有可无，因为openstack支持命令行方式

### 2.9 heat组件
提供编排服务
编排服务就是说，一创建云服务来说，常规的方式就是在web界面上面选择参数，所谓的编排呢，就是创建资源的另一种方式，后面在K8S里面创建资源都是以所谓的编排的方式


# Docker
<span style="background:#affad1">容器和传统虚拟机的区别</span>
## 一.容器介绍
轻量级虚拟化技术
创建速度特别快；秒级
创建了 保证某业务正常运行的必备的应用程序/指令
![[Pasted image 20240715093641.png]]
为什么创建速度快？
1.容器是没有自己的虚拟硬件的，没有独立的内核
2.共享物理机内核，所以容器的IO速度要比传统的虚拟机快
 容器里面只有能维持那个软件正常运行必要的一些指令
假设有一个mysql镜像，创建出了mysql容器，从容器创建好的那一刻开始，mysql软件都是装好的，mysql相关的指令也都存在

![[Pasted image 20240715190311.png]]
<span style="background:#affad1">传统的虚拟机</span>要上网，从app产生一份数据，交给虚拟机的虚拟内核，如果磁盘或者网卡装了半虚拟化驱动的话，这个数据会直接绕过虚拟硬件到hypervisor虚拟机管理软件，再到真实物理机的内核，然后再通过真实物理机的网卡出去
<span style="background:#affad1">容器</span>他并不是一个完整的系统，它上面只是有一堆应用程序，所以他们是共享物理机内核，这就意味着容器将来想借助你物理网卡上网的话，容器产生的数据直接就能到物理机内核然后通过物理网卡转出去

有容器之前和没容器的时候有什么区别？
(1)快速的构建业务，根据公司业务自定义镜像
(2)从业务迁移的角度叫，提供了很大的便利

1.容器的优势
快速部署业务环境；平台
便于业务迁移，避免兼容性问题

容器的三要素
容器，镜像，仓库
![[Pasted image 20240715102954.png]]
容器相关的核心技术
容器之间是怎么实现资源隔离的？
传统的虚拟机通过虚拟内核就可以实现资源隔离
容器资源隔离
<span style="background:#affad1">namespace 命名空间</span>
实现资源隔离(文件目录，用户，端口，进程)
创建容器的时候会自动生成一个命名空间，然后吧容器放到这个空间里面实现资源隔离
<span style="background:#affad1">cgroup 控制组</span>
实现容器的资源限制(cpu,内存)
实际的生产环境里面，每个机器必须做资源限制

容器的管理工具/软件
docker
docker-ce;docker-ee
podman 跟docker一模一样
containerd

## 二.安装docker
### 1.配置docker软件仓库
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
cat /etc/yum.repos.d/docker-ce.repo
```bash
[docker-ce]
name=docker-ce
baseurl=https://mirrors.aliyun.com/docker- ce/linux/centos/7.9/x86_64/stable/
enabled=1
gpgcheck=0
```
### 2.安装docker, 启动docker服务
yum install -y docker-ce
rpm -q docker-ce
![[Pasted image 20240715111547.png]]
systemctl enable --now docker
### 3.配置国内docker镜像仓库
cat /etc/docker/daemon.json
![[Pasted image 20240715111655.png|500]]
![[Pasted image 20240715111723.png]]
### 4.主机网络变化
ifconfig
![[Pasted image 20240715111904.png]]
cat /proc/sys/net/ipv4/ip_forward
![[Pasted image 20240715111938.png]]
iptables -t nat -nL
![[Pasted image 20240715112538.png]]

## 三.镜像基础操作
### 1.查看镜像列表
docker image ls 
![[Pasted image 20240715113429.png]]
TAG：标记镜像的版本
### 2.搜索镜像
docker search nginx
### 3.下载镜像
docker pull nginx:1.18
### 4.导入镜像
docker load -i centos7.tar
### 5.导出镜像
docker save -o tomcat.tar tomcat:latest
### 6.删除镜像
docker rmi id 
### 7.查看镜像详情
docker image inspect centos:7
查看镜像的详细信息，找Cmd的关键字

## 四.创建容器
### 1.格式
docker run [选项] 镜像名称 [命令]
我是用什么镜像创建容器，设置容器执行什么命令
-t -i 提供一个终端命令提示符
-d 后台运行
任何一个容器的运行必须依赖于一个持续运行的进程存在
docker run -tid centos:7 /bin/bash


## 五.容器管理的常用操作
### 1.查看容器
docker ps -a
### 2.查看容器的详情
docker inspect id
### 3.查看容器的日志
docker logs  id
### 4.连接登录容器
docker exec -ti id bash
### 5.删除容器
docker rm id 
docker rm -f id 强制删除
### 6.启动/停止/重启容器
docker [start|stop|restart] 容器ID/名称
### 7.杀死容器
docker kill id
### 8.导出容器
docker export -o suiyi.tar id 
### 9.导入容器
docker import suiyi.tar
![[Pasted image 20240715202714.png]]
导入之后还是一个镜像，然后还是要根据这个镜像重新创建容器
![[Pasted image 20240715202731.png]]
修改名字跟tag
docker tag 555308ffc1d7 suiyi:1003
docker run -tid suiyi:1003 /bin/bash
docker run -tid --name xxx  image_id /bin/bash
![[Pasted image 20240715202855.png]]

## 六.容器常用选项

### 1.后台运行
-d 
### 2.指定容器名字 主机名字
--name=test1 --hostname=test1 
```bash
docker run -tid --name=test1 --hostname=test1 centos:7 
docker exec -ti test1 bash
```
### 3.设置开启自启
--restart=always 
```bash
docker run -tid --name=test2 --hostname=test2 --restart=always centos:7 
```
### 4.发布容器内容
<span style="background:#affad1">-p 物理机端口:容器端口</span>
```bash
docker run -tid --name=test4 --hostname=test4  nginx:1.18 
```
现在我们机器里的这个80端口谁可以访问？
跑docker的这个物理机可以访问，其他docke容器也可以访问
如果想外界可以访问，第一种方式就是通过nat转换(dnat)
docker思想上是这样的，但是操作不是这样

容器一点创建好以后，里面的东西就已经固定了没法改变
```bash
docker run -tid --name=test4 --hostname=test4 -p 80:80 nginx:1.18 
```
![[Pasted image 20240715203734.png]]
![[Pasted image 20240715210340.png]]
![[Pasted image 20240715210553.png]]
-P 随机发布端口
docker run -tid --name=test6 --hostname=test6 -P nginx:1.18 
从三万多开始

### 5.传递环境变量
https://hub.docker.com/
-e 变量名称=值
docker run -tid --name=test7 --hostname=test7 
-e NAME=martin centos:7 
![[Pasted image 20240715210950.png]]
 docker run -tid mysql:5.7 
![[Pasted image 20240715211226.png]]
![[Pasted image 20240715211247.png]]
容器建出来就是挂的
查看日志
docker logs  4a3a
![[Pasted image 20240715211408.png]]
后面必须添加参数传递环境变量

```bash
docker run -tid --name=test8 --hostname=test8 
-e MYSQL_ROOT_PASSWORD=redhat mysql:5.7 

docker run -tid --name=test9 --hostname=test9 \
> -e MYSQL_ROOT_PASSWORD=redhat \
> -e MYSQL_DATABASE=it \
> -e MYSQL_USER=admin \
> -e MYSQL_PASSWORD=redhat \
> mysql:5.7
```
![[Pasted image 20240715211653.png]]

### 6.容器持久化保存
<span style="background:#affad1">-v 物理机目录:容器目录</span>
docker run -tid --name=test1 --hostname=test1 -v /opt/test1:/test1 centos:7 
docker exec -ti test1 bash
![[Pasted image 20240715211858.png]]
查看镜像对应的持久化目录， 使用docker image inspect查看详细信息找Volumes关键字
docker image inspect 8cf625070931
![[Pasted image 20240715212202.png]]\
```bash
docker run -tid --name=test2 --hostname=test2 \
> -e MYSQL_ROOT_PASSWORD=redhat \
> -v /opt/test2/:/var/lib/mysql \
> mysql:5.7 
```
多个容器挂载同一个目录
docker run -tid --name=test3 --hostname=test3 -v /opt/test1/:/test3 centos:7 
 docker run -tid --name=test4 --hostname=test4 -v /opt/test1/:/test4 centos:7 
docker exec -ti test30 bash
![[Pasted image 20240715212630.png]]
![[Pasted image 20240715212639.png]]
![[Pasted image 20240715212649.png]]



### 7.容器中应用的配置文件
-v
把配置文件在物理机上准备好

![[Pasted image 20240716091034.png]]
![[Pasted image 20240716091115.png]]
### 8.定义容器的通信别名

--link=容器名:别名
容器不允许使用IP通信
### 9.容器的资源限制
--cpus
--memory

### 10.小练习
前期规划：
#### (1)mysql 主从
主 配置文件
/opt/mysql_master
[mysqld]
server_id=1
log_bin=master
gtid_mode=ON 
enforce_gtid_consistency=true 
从配置文件
/opt/mysql_slave
[mysqld]
server_id=2
log_bin=master
gtid_mode=ON 
enforce_gtid_consistency=true 

创建主虚拟机
```bash
docker run -tid --name=mysql_master --hostname=mysql_master -v /opt/mysql_master:/etc/my.cnf \
--cpus=1 --memory=400M \
-e MYSQL_ROOT_PASSWORD=redhat  mysql:5.7
```
创建从虚拟机
```bash
docker run -tid --name=mysql_slave --hostname=mysql_slave \
--link=mysql_master:mysql_master \
-v /opt/mysql_slave:/etc/my.cnf \
--cpus=1 --memory=400M \
-e MYSQL_ROOT_PASSWORD=redhat mysql:5.7
```

用户的创建再mysql内部创建
docker exec -ti mysql_master bash
mysql> create user 'repluser'@'%' identified by '[WWW.1.com](http://WWW.1.com)';
mysql> grant replication slave ON _._ TO 'repluser'@'%';
mysql> FLUSH PRIVILEGES;

docker exec -ti mysql_slave bash
mysql> CHANGE MASTER TO 
-> MASTER_HOST="mysql_master",
-> MASTER_USER="repluser", 
-> MASTER_PASSWORD="[WWW.1.com](http://WWW.1.com)", 
-> MASTER_AUTO_POSITION=1; 
mysql> START SLAVE;
mysql> SHOW SLAVE STATUS\G;
![[Pasted image 20240716105941.png]]
主从复制完毕


#### (2)创建业务容器
wordpress

首先主库创建wordpress连接用户
create database wordpress charset utf8;
create user 'wpuser'@'%' identified by 'WWW.1.com';
grant all on wordpress.* to 'wpuser'@'%';
flush privileges;

```bash
docker run -tid --name=wordpress1 --hostname=wordpress1 \
--link=mysql_master:mysql_master \
--cpus=1 --memory=1024M \
-e  WORDPRESS_DB_HOST=mysql_master \
-e  WORDPRESS_DB_USER=wpuser \
-e WORDPRESS_DB_PASSWORD=WWW.1.com \
-e WORDPRESS_DB_NAME=wordpress  \
-p 80:80 wordpress

```

```bash
docker run -tid --name=wordpress2 --hostname=wordpress2 \
--link=mysql_master:mysql_master \
--cpus=1 --memory=1024M \
-e  WORDPRESS_DB_HOST=mysql_master \
-e  WORDPRESS_DB_USER=wpuser \
-e WORDPRESS_DB_PASSWORD=WWW.1.com \
-e WORDPRESS_DB_NAME=wordpress  \
-p 81:80 wordpress
```

![[Pasted image 20240716112929.png]]
测试成功

#### (3)负载均衡
```bash
docker run -tid --name=haproxy --hostname=haproxy \
--link=wordpress1:wordpress1 \
--link=wordpress2:wordpress2 \
--cpus=1 --memory=1024M \
-v /opt/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg  \
-p 8000:8000 haproxy
```
准备haproxy配置文件
vim /etc/haproxy/haproxy.cfg 
![[Pasted image 20240716113954.png]]


```bash
frontend web_service
   bind 0.0.0.0:8000
   mode http
   option forwardfor	
   use_backend blog			
backend blog
   balance roundrobin
   mode http
   server wordpress1 wordpress1:80 check
   server wordpress2 wordpress2:80 check
```

容器和物理器之间相互cp数据
docker cp wordpres1:/wordpress.sql   ./


## 七.堡垒机/跳板机
![[Pasted image 20240716160037.png]]
### 1.jumpserver安装使用
#### (1)生成jumpserver需要的密钥
```bash
cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 50
B5Df26hgzQffkqPYCodUmhDhrcIl7OlJuYxBBnzpbnKQnjoc5u
cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 20
yTn6VcSyW7VBs2kGvoOR
```
#### (2)创建容器运行jumpserver
```bash
docker run -tid --name=jumpserver --hostname=jumpserver \
 --restart=always \
 -p 83:80 -p 2222:2222 \
 -e SECRET_KEY= B5Df26hgzQffkqPYCodUmhDhrcIl7OlJuYxBBnzpbnKQnjoc5u \
 -e BOOTSTRAP_TOKEN=yTn6VcSyW7VBs2kGvoOR \
 -v /opt/jumpserver/data:/opt/jumpserver/data \
 -v /opt/jumpserver/mysql:/var/lib/mysql \
 jumpserver/jms_all:v2.8.4 
```
![[Pasted image 20240716192221.png]]
#### (3)客户端登录
ssh admin@192.168.140.21:2222 
![[Pasted image 20240716192152.png]]

123123
1212



